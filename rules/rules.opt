# Rule: Eliminate jump to next line
pattern:
  jp $1
$1
replacement:
$1

# Rule: Remove redundant exchange
pattern:
;#ZOPT
  push hl
  pop de
  ex de,hl
replacement:
-

# Rule: Remove redundant push/pop
pattern:
  push hl
  ld hl,$1
  ex de,hl
  pop hl
pattern:  
  ld de,$1

# Rule: Optimize increment int by 1
pattern:
  push hl
  ld hl,1
  pop de
  add hl,de
replacement:
  inc hl

pattern:
  ld de,$1
  ld hl,1
  add hl,de
replacement:
  ld hl,$1
  inc hl

pattern:
  ld de,1
  add hl,de
replacement:
  inc hl

# Rule: Optimize decrement int by 1
pattern:
  push hl
  ld hl,1
  pop de
  ex de,hl
  xor a
  sbc hl,de
replacement:
  dec hl

pattern:
  ld de,$1
  ld hl,1
  ex de,hl
  xor a
  sbc hl,de
replacement:
  ld hl,$1
  dec hl

pattern:
  ld de,65535
  add hl,de
replacement:
  dec hl

# Rule : Global array 0 Index
pattern:
  ld hl,0
  push hl
  ld hl,$1
  pop de
  add hl,de
replacement:
  ld hl,$1

# Rule : Global array const Index
pattern:
  ld hl,$1
  push hl
  ld hl,$2
  pop de
  add hl,de
constraints:
  ($1 isnumeric) (($2 isnumeric) ($2 "_" startswith) or) and
replacement:
  ld hl,$2+$1

# Rule : Global Char array variable Index
pattern:
  ld hl,$1
  push hl
  ld hl,$2
  pop de
  add hl,de
replacement:
  ld de,$1
  ld hl,$2
  add hl,de

# Rule : Global Char array complex Index
pattern:
  push hl
  ld hl,$1
  pop de
  add hl,de
replacement:
  ld de,$1
  add hl,de

# Rule : HL to DE
pattern:
  ld l,$1
  ld h,$2   
  ld e,l
  ld d,h
replacement:
  ld e,$1
  ld d,$2

# Rule: Eliminate register reload
pattern:
  ld $1,$2
  ld $2,$1
replacement:
  ld $1,$2

# Rule: Optimize increment byte by 1
pattern:
  call ccsxt
  push hl
  ld hl,1
  pop de
  add hl,de
  ld a,l
replacement:
  inc a

# Rule: Optimize decrement byte by 1
pattern:
  call ccsxt
  push hl
  ld hl,1
  pop de
  ex de,hl
  xor a
  sbc hl,de
  ld a,l
replacement:
  dec a

# Rule: Optimize byte addition
pattern:
  call ccsxt
  push hl
  ld a,$1
  call ccsxt
  pop de
  add hl,de
  ld a,l
replacement:
  ld b,$1
  add a,b

# Rule: Optimize byte subtraction
pattern:
  call ccsxt
  push hl
  ld a,$1
  call ccsxt
  pop de
  ex de,hl
  xor a
  sbc hl,de
  ld a,l
replacement:
  ld b,$1
  sub a,b

# Rule: Optimize const load into HL & DE
pattern:
  ld hl,$1
  push hl
  ld hl,$2
  pop de
replacement:
  ld de,$1
  ld hl,$2

# Rule: Optimize const load into local
pattern:
  ld hl,$1
  ld $2,h
  ld $3,l
constraints:
  ($1 isnumeric) ($1 '_' startswith) or
replacement:
  ld $2,+($1>>8)&255
  ld $3,+($1&255)

# Rule : Optimize load into DE
pattern:
  push hl
  ld hl,$1
  pop de
  ex de,hl
replacement:  
  ld de,$1

# Rule : Optimize load into DE
pattern:
  push hl
  ld l,$1
  ld h,$2  
  ex de,hl
  pop hl
replacement:  
  ld e,$1
  ld d,$2

# Rule : Optimize load into DE
pattern:
  push hl
  ld hl,$1
  ex de,hl
  pop hl
replacement:
  ld de,$1  

# Rule: Optimize expressions with HL loaded
pattern:
  ex de,hl
  push hl
  ld hl,$1
  pop de
replacement:
  ld hl,$1

# Rule: Optimize expressions with locals
pattern:
  ld l,$2
  ld h,$1  
  push hl  
  ld l,$4
  ld h,$3
  pop de
replacement:
  ld e,$2
  ld d,$1  
  ld l,$4
  ld h,$3

pattern:
  ld l,$1
  ld h,$2
  push hl
  ld l,$1
  ld h,$2
replacement:
  ld l,$1
  ld h,$2
  push hl

pattern:
  ld l,$2
  ld h,$1  
  push hl
  ld hl,$3
  pop de
constraints:
  ($3 isnumeric) ($3 1 <>) and
replacement:
  ld e,$2
  ld d,$1  
  ld hl,$3

# Rule: Optimize char variable load
pattern:
  ld a,$1
  call ccsxt
  ld a,l
replacement:
  ld a,$1

# Rule : L to B (from HL)
pattern:
  ld hl,$1
  ld b,l
constraints:
  ($1 isnumeric)
replacement:
  ld b,$1

# Rule : HL to var, var to DE
pattern:
  ld $1,h
  ld $2,l
  ld d,$1
  ld e,$2
replacement:
  ld $1,h
  ld $2,l
  ld d,h
  ld e,l

# Rule : Optimize out port <= 255
pattern:
  ld hl,$1
  ld c,l
  ld b,h    
  ld hl,$2
  out (c),l
constraints:
  ($1 isnumeric) ($1 255 <=) and
replacement:
  ld a,$2
  out ($1),a

# Rule : Optimize out port > 255
pattern:
  ld hl,$1
  ld c,l
  ld b,h  
  ld hl,$2
  out (c),l
replacement:
  ld bc,$1
  ld a,$2
  out (c),a

# Rule : Optimize out (global)
pattern:
  ld hl,$1
  ld bc,$2
  out (c),l
replacement:
  ld a,$1
  ld bc,$2
  out (c),a

# Rule : Optimize out (global))
pattern:
  ld a,$1
  call ccsxt
  ld bc,$2
  out (c),l
replacement:
  ld a,$1
  ld bc,$2
  out (c),a

# Rule : Optimize out (local)
pattern:
  ld l,$2
  ld h,$1  
  ld bc,$3
  out (c),l
replacement:
  ld a,$2
  ld bc,$3
  out (c),a

# Rule : Optimize out port <= 255
pattern:
  ld bc,$1
  out (c),a
constraints:
  ($1 isnumeric) ($1 255 <=) and
replacement:
  out ($1),a

# Rule : Optimize nextreg *,*
pattern:
  ld de,$1
  ld hl,$2
  ld bc,9275
  out (c),e
  inc b
  out (c),l
constraints:
  ($1 isnumeric) ($2 isnumeric) and
replacement:
  nreg $1,$2

# Rule : Optimize nextreg *,a
pattern:
  ld de,$1
  ld hl,$2
  ld bc,9275
  out (c),e
  inc b
  out (c),l
constraints:
  ($1 isnumeric)
replacement:
  ld a,$2
  nreg $1,a

# Rule : Optimize nextreg *,a
pattern:
  ld de,$1
  ld hl,$2
  ld bc,9275
  out (c),e
  inc b
  out (c),l
replacement:
  ld a,$1
  ld bc,9275
  out (c),a
  inc b
  ld a,$2
  out(c),a

# Rule : Optimize nextreg *,a
pattern:
  ld hl,$1
  push hl
  ld a,$2
  call ccsxt
  pop de
  ld bc,9275
  out (c),e
  inc b
  out (c),l
constraints:
  ($1 isnumeric)
replacement:
  ld a,$2
  nreg $1,a

# Rule : Optimize nextreg
pattern:
  ld a,$1
  push hl
  ld a,$2
  call ccsxt
  pop de
  ld bc,9275
  out (c),e
  inc b
  out (c),l
replacement:
  ld a,$1
  ld bc,9275
  out (c),a
  inc b
  ld a,$2
  out(c),a

# Rule : Optimize nextreg
pattern:
  ld a,$1
  call ccsxt
  push hl
  ld a,$2
  call ccsxt
  pop de
  ld bc,9275
  out (c),e
  inc b
  out (c),l
replacement:
  ld a,$1
  ld bc,9275
  out (c),a
  inc b
  ld a,$2
  out(c),a

# Rule : Optimize nextreg
pattern:
  ld a,$1
  call ccsxt
  push hl
  ld hl,$2
  pop de
  ld bc,9275
  out (c),e
  inc b
  out (c),l
replacement:
  ld a,$1
  ld bc,9275
  out (c),a
  inc b
  ld a,$2
  out(c),a

# Rule : Optimize nextreg
pattern:
  ld hl,$1
  push hl
  ld a,$2
  call ccsxt
  pop de
  ld bc,9275
  out (c),e
  inc b
  out (c),l
replacement:
  ld a,$1
  ld bc,9275
  out (c),a
  inc b
  ld a,$2
  out(c),a

# Rule : Optimize nextreg (locals)
pattern:
  ld hl,$1
  push hl
  ld l,$3
  ld h,$2
  pop de
  ld bc,9275
  out (c),e
  inc b
  out (c),l
replacement:
  ld a,$1
  ld bc,9275
  out (c),a
  inc b
  ld a,$3
  out(c),a

# Rule : Optimize nextreg (locals)
pattern:
  ld d,$1
  ld e,$2
  ld hl,$3
  ld bc,9275
  out (c),e
  inc b
  out (c),l
replacement:
  ld a,$2
  ld bc,9275
  out (c),a
  inc b
  ld a,$3
  out(c),a

# Rule : Optimize nextreg (locals)
pattern:
  ld d,$1
  ld e,$2
  ld h,$3
  ld l,$4
  ld bc,9275
  out (c),e
  inc b
  out (c),l
replacement:
  ld a,$2
  ld bc,9275
  out (c),a
  inc b
  ld a,$4
  out(c),a

# Rule : Optimize nextreg (locals+global)
pattern:
  ld a,$1
  ld bc,9275
  out (c),a
  inc b
  ld a,$2
  out(c),a
constraints:
  ($1 isnumeric)
replacement:
  ld a,$2
  nreg $1,a

pattern:
  ld l,$2
  ld h,$1  
  push hl
  ld hl,$3
  pop de
  ld bc,9275
  out (c),e
  inc b
  out (c),l
replacement:
  ld a,$2
  ld bc,9275
  out (c),a
  inc b
  ld a,$3
  out(c),a

# Rule : Optimize nextreg (locals+global)
pattern:
  ld l,$2
  ld h,$1  
  push hl
  ld a,$3
  call ccsxt
  pop de
  ld bc,9275
  out (c),e
  inc b
  out (c),l
replacement:
  ld a,$2
  ld bc,9275
  out (c),a
  inc b
  ld a,$3
  out(c),a

# Rule : Optimize nextreg (locals+global)
pattern:
  ld a,$1
  call ccsxt
  push hl
  ld l,$3
  ld h,$2  
  pop de
  ld bc,9275
  out (c),e
  inc b
  out (c),l
replacement:
  ld a,$1
  ld bc,9275
  out (c),a
  inc b
  ld a,$3
  out(c),a
  
# Rule : Optimize member loads
pattern:
  ld hl,$1
  ld a,(hl)
  inc hl
  ld l,a
  ld h,(hl)  
constraints:
  ($1 '_' startswith)
replacement:
  ld hl,($1)

# Rule : Optimize redundant push/pop
pattern:
  push $1
  pop $1
replacement:
-

# Rule : Zero values
pattern:
  ld hl,0
  ld $1,l
  ld $2,h
replacement:
  xor a
  ld $1,a
  ld $2,a

# Rule : Optimize unnecessary HL/DE swap (local)
pattern:
  ld e,$1
  ld d,$2
  ld l,$3
  ld h,$4
  ex de,hl
replacement:
  ld e,$3
  ld d,$4
  ld l,$1
  ld h,$2

# Rule : Optimize bit shift by constant (local)
pattern:
  ld l,$1
  ld h,$2
  push hl
  ld hl,$3
  pop de
  ld b,l
  $4 de,b
constraints:
  ($3 isnumeric)
replacement:
  ld e,$1
  ld d,$2
  ld b,$3
  $4 de,b

